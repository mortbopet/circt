// NOTE: Assertions have been autogenerated by utils/update_mlir_test_checks.py
// RUN: circt-opt -handshake-insert-buffer=strategies=cycles %s | FileCheck %s
// RUN: circt-opt -handshake-insert-buffer=strategies=all %s | circt-opt -handshake-insert-buffer=strategies=all | FileCheck %s -check-prefix=ALL
module {
  handshake.func @simple_loop(%arg0: none, ...) -> none {
    // ALL: buffer
    // ALL-NOT: buffer
    // ALL: br
    %0 = br %arg0 : none
    // ALL: buffer
    %1:2 = control_merge %0 : none
    // ALL: buffer
    %2:3 = fork [3] %1#0 : none
    // ALL: buffer
    sink %1#1 : index
    // ALL: buffer
    %3 = constant %2#1 {value = 1 : index} : index
    // ALL: buffer
    %4 = constant %2#0 {value = 42 : index} : index
    // ALL: buffer
    %5 = br %2#2 : none
    // ALL: buffer
    %6 = br %3 : index
    // ALL: buffer
    %7 = br %4 : index
    // ALL: buffer
    %8 = mux %11#1 [%22, %7] : index, index
    // ALL: buffer
    %9:2 = fork [2] %8 : index
    // ALL: buffer
    // CHECK:       %10:2 = control_merge(%28, %5) : (none, none) -> (none, index)
    // CHECK-NEXT:  %11 = buffer %10#0 {control = true, sequential = true, slots = 2 : i32} : (none) -> none
    %10:2 = control_merge %23, %5 : none
    // ALL: buffer
    // CHECK:       %12:2 = fork %10#1 : index
    // CHECK-NEXT:  %13 = buffer %12#1 {control = false, sequential = true, slots = 2 : i32} : index
    %11:2 = fork [2] %10#1 : index
    // ALL: buffer
    %12 = mux %11#0 [%24, %6] : index, index
    // ALL: buffer
    // CHECK:       %15:2 = fork %14 : index
    // CHECK-NEXT:  %16 = buffer %15#1 {control = false, sequential = true, slots = 2 : i32} : index
    // CHECK-NEXT:  %17 = buffer %15#0 {control = false, sequential = true, slots = 2 : i32} : index
    %13:2 = fork [2] %12 : index
    // ALL: buffer
    %14 = arith.cmpi slt, %13#1, %9#1 : index
    // ALL: buffer
    %15:3 = fork [3] %14 : i1
    // ALL: buffer
    %trueResult, %falseResult = cond_br %15#2, %9#0 : index
    // ALL: buffer
    sink %falseResult : index
    // ALL: buffer
    %trueResult_0, %falseResult_1 = cond_br %15#1, %10#0 : none
    // ALL: buffer
    %trueResult_2, %falseResult_3 = cond_br %15#0, %13#0 : index
    // ALL: buffer
    sink %falseResult_3 : index
    // ALL: buffer
    %16 = merge %trueResult_2 : index
    // ALL: buffer
    %17 = merge %trueResult : index
    // ALL: buffer
    %18:2 = control_merge %trueResult_0 : none
    // ALL: buffer
    %19:2 = fork [2] %18#0 : none
    // ALL: buffer
    sink %18#1 : index
    // ALL: buffer
    %20 = constant %19#0 {value = 1 : index} : index
    // ALL: buffer
    %21 = arith.addi %16, %20 : index
    // ALL: buffer
    // CHECK:       %26 = br %21 : index
    // CHECK-NEXT:  %27 = buffer %26 {control = false, sequential = true, slots = 2 : i32} : index
    %22 = br %17 : index
    // ALL: buffer
    %23 = br %19#1 : none
    // ALL: buffer
    %24 = br %21 : index
    // ALL: buffer
    %25:2 = control_merge %falseResult_1 : none
    // ALL: buffer
    sink %25#1 : index
    // ALL: buffer
    return %25#0 : none
  }
}
