//===- SymUniquer.h - Declare Symbol Uniquer --------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file declares a Symbol Uniquer.
//
//===----------------------------------------------------------------------===//

#ifndef CIRCT_SUPPORT_SYMUNIQUER_H
#define CIRCT_SUPPORT_SYMUNIQUER_H

#include "circt/Support/SymCache.h"

namespace circt {

/// The SymbolUniquer is used to generate unique names based on some set of
/// existing names defined through a SymbolCache.
class SymbolUniquer {
  /// Uniquer function which suffixes a base name with an integer, starting at
  /// 0.
  static std::pair<std::string, llvm::Any>
  integerUniquer(mlir::StringRef name, llvm::Any previousToken) {
    unsigned cntr = 0;
    if (previousToken.hasValue())
      cntr = llvm::any_cast<unsigned>(previousToken) + 1;
    return {name.str() + "_" + std::to_string(cntr), cntr};
  }

public:
  /// A uniquer function is used to iteratively generate a permutation of
  /// a base name based on some token. The uniquer function is responsible for
  /// adjusting output tokens based on input tokens to ensure convergence.
  /// signature:
  ///  [uniqueName, tokenUsed] = UniquerFn(baseName, previousToken)
  /// uniqueName:
  ///   unique name generated by the function.
  /// tokenUsed:
  ///   llvm::Any typed value of the token that was used to generate
  ///   the unique name baseName: base name provided by the user. This stays
  ///   constant through all iterations.
  /// previousToken:
  ///   llvm::Any typed value of the token that was used in the previous
  ///   execution of this function. On the first run, this carries no value, and
  ///   it is the responsability of the UniquerFn to generate the initial token.
  using UniquerFn = llvm::function_ref<std::pair<std::string, llvm::Any>(
      mlir::StringRef, llvm::Any /*token*/)>;
  SymbolUniquer(mlir::MLIRContext *ctx, SymbolCacheBase *cache,
                UniquerFn uniquerFn = &integerUniquer)
      : ctx(ctx), cache(cache), uniquerFn(uniquerFn) {}

  /// Return a unique permutation of 'name' wrt. the names present in the cache
  /// of this SymbolUniquer.
  std::string getUniqueName(mlir::StringRef name) {
    llvm::Any uniquerToken;
    std::string uniqueName = name.str();

    // Iterate until the cache reports back that no definition was found for the
    // given name.
    while (cache->getDefinition(mlir::StringAttr::get(ctx, uniqueName)))
      std::tie(uniqueName, uniquerToken) = uniquerFn(name, uniquerToken);
    return uniqueName;
  }

private:
  mlir::MLIRContext *ctx = nullptr;
  SymbolCacheBase *cache;
  UniquerFn uniquerFn;
};

} // namespace circt

#endif // CIRCT_SUPPORT_SYMUNIQUER_H
